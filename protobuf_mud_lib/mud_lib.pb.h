// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mud_lib.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mud_5flib_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mud_5flib_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mud_5flib_2eproto;
namespace mud {
class attribute;
class attributeDefaultTypeInternal;
extern attributeDefaultTypeInternal _attribute_default_instance_;
class character;
class characterDefaultTypeInternal;
extern characterDefaultTypeInternal _character_default_instance_;
class character_book;
class character_bookDefaultTypeInternal;
extern character_bookDefaultTypeInternal _character_book_default_instance_;
class character_state;
class character_stateDefaultTypeInternal;
extern character_stateDefaultTypeInternal _character_state_default_instance_;
class direction;
class directionDefaultTypeInternal;
extern directionDefaultTypeInternal _direction_default_instance_;
class enemy;
class enemyDefaultTypeInternal;
extern enemyDefaultTypeInternal _enemy_default_instance_;
class enemy_book;
class enemy_bookDefaultTypeInternal;
extern enemy_bookDefaultTypeInternal _enemy_book_default_instance_;
class login_in;
class login_inDefaultTypeInternal;
extern login_inDefaultTypeInternal _login_in_default_instance_;
class login_out;
class login_outDefaultTypeInternal;
extern login_outDefaultTypeInternal _login_out_default_instance_;
class logout_in;
class logout_inDefaultTypeInternal;
extern logout_inDefaultTypeInternal _logout_in_default_instance_;
class logout_out;
class logout_outDefaultTypeInternal;
extern logout_outDefaultTypeInternal _logout_out_default_instance_;
class neighbour;
class neighbourDefaultTypeInternal;
extern neighbourDefaultTypeInternal _neighbour_default_instance_;
class play_in;
class play_inDefaultTypeInternal;
extern play_inDefaultTypeInternal _play_in_default_instance_;
class play_out;
class play_outDefaultTypeInternal;
extern play_outDefaultTypeInternal _play_out_default_instance_;
class player;
class playerDefaultTypeInternal;
extern playerDefaultTypeInternal _player_default_instance_;
class player_book;
class player_bookDefaultTypeInternal;
extern player_bookDefaultTypeInternal _player_book_default_instance_;
class select_character_in;
class select_character_inDefaultTypeInternal;
extern select_character_inDefaultTypeInternal _select_character_in_default_instance_;
class select_character_out;
class select_character_outDefaultTypeInternal;
extern select_character_outDefaultTypeInternal _select_character_out_default_instance_;
class tile;
class tileDefaultTypeInternal;
extern tileDefaultTypeInternal _tile_default_instance_;
class tile_book;
class tile_bookDefaultTypeInternal;
extern tile_bookDefaultTypeInternal _tile_book_default_instance_;
class token_in;
class token_inDefaultTypeInternal;
extern token_inDefaultTypeInternal _token_in_default_instance_;
class token_out;
class token_outDefaultTypeInternal;
extern token_outDefaultTypeInternal _token_out_default_instance_;
}  // namespace mud
PROTOBUF_NAMESPACE_OPEN
template<> ::mud::attribute* Arena::CreateMaybeMessage<::mud::attribute>(Arena*);
template<> ::mud::character* Arena::CreateMaybeMessage<::mud::character>(Arena*);
template<> ::mud::character_book* Arena::CreateMaybeMessage<::mud::character_book>(Arena*);
template<> ::mud::character_state* Arena::CreateMaybeMessage<::mud::character_state>(Arena*);
template<> ::mud::direction* Arena::CreateMaybeMessage<::mud::direction>(Arena*);
template<> ::mud::enemy* Arena::CreateMaybeMessage<::mud::enemy>(Arena*);
template<> ::mud::enemy_book* Arena::CreateMaybeMessage<::mud::enemy_book>(Arena*);
template<> ::mud::login_in* Arena::CreateMaybeMessage<::mud::login_in>(Arena*);
template<> ::mud::login_out* Arena::CreateMaybeMessage<::mud::login_out>(Arena*);
template<> ::mud::logout_in* Arena::CreateMaybeMessage<::mud::logout_in>(Arena*);
template<> ::mud::logout_out* Arena::CreateMaybeMessage<::mud::logout_out>(Arena*);
template<> ::mud::neighbour* Arena::CreateMaybeMessage<::mud::neighbour>(Arena*);
template<> ::mud::play_in* Arena::CreateMaybeMessage<::mud::play_in>(Arena*);
template<> ::mud::play_out* Arena::CreateMaybeMessage<::mud::play_out>(Arena*);
template<> ::mud::player* Arena::CreateMaybeMessage<::mud::player>(Arena*);
template<> ::mud::player_book* Arena::CreateMaybeMessage<::mud::player_book>(Arena*);
template<> ::mud::select_character_in* Arena::CreateMaybeMessage<::mud::select_character_in>(Arena*);
template<> ::mud::select_character_out* Arena::CreateMaybeMessage<::mud::select_character_out>(Arena*);
template<> ::mud::tile* Arena::CreateMaybeMessage<::mud::tile>(Arena*);
template<> ::mud::tile_book* Arena::CreateMaybeMessage<::mud::tile_book>(Arena*);
template<> ::mud::token_in* Arena::CreateMaybeMessage<::mud::token_in>(Arena*);
template<> ::mud::token_out* Arena::CreateMaybeMessage<::mud::token_out>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mud {

enum direction_direction_enum : int {
  direction_direction_enum_NORTH = 0,
  direction_direction_enum_SOUTH = 1,
  direction_direction_enum_EAST = 2,
  direction_direction_enum_WEST = 3,
  direction_direction_enum_direction_direction_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  direction_direction_enum_direction_direction_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool direction_direction_enum_IsValid(int value);
constexpr direction_direction_enum direction_direction_enum_direction_enum_MIN = direction_direction_enum_NORTH;
constexpr direction_direction_enum direction_direction_enum_direction_enum_MAX = direction_direction_enum_WEST;
constexpr int direction_direction_enum_direction_enum_ARRAYSIZE = direction_direction_enum_direction_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* direction_direction_enum_descriptor();
template<typename T>
inline const std::string& direction_direction_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, direction_direction_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function direction_direction_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    direction_direction_enum_descriptor(), enum_t_value);
}
inline bool direction_direction_enum_Parse(
    const std::string& name, direction_direction_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<direction_direction_enum>(
    direction_direction_enum_descriptor(), name, value);
}
enum attribute_attribute_name : int {
  attribute_attribute_name_LIFE = 0,
  attribute_attribute_name_STRENGTH = 1,
  attribute_attribute_name_AGILITY = 2,
  attribute_attribute_name_INTELLIGENCE = 3,
  attribute_attribute_name_attribute_attribute_name_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  attribute_attribute_name_attribute_attribute_name_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool attribute_attribute_name_IsValid(int value);
constexpr attribute_attribute_name attribute_attribute_name_attribute_name_MIN = attribute_attribute_name_LIFE;
constexpr attribute_attribute_name attribute_attribute_name_attribute_name_MAX = attribute_attribute_name_INTELLIGENCE;
constexpr int attribute_attribute_name_attribute_name_ARRAYSIZE = attribute_attribute_name_attribute_name_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* attribute_attribute_name_descriptor();
template<typename T>
inline const std::string& attribute_attribute_name_Name(T enum_t_value) {
  static_assert(::std::is_same<T, attribute_attribute_name>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function attribute_attribute_name_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    attribute_attribute_name_descriptor(), enum_t_value);
}
inline bool attribute_attribute_name_Parse(
    const std::string& name, attribute_attribute_name* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<attribute_attribute_name>(
    attribute_attribute_name_descriptor(), name, value);
}
enum character_state_character_state_enum : int {
  character_state_character_state_enum_NONE = 0,
  character_state_character_state_enum_WALKING = 1,
  character_state_character_state_enum_COMBAT = 2,
  character_state_character_state_enum_character_state_character_state_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  character_state_character_state_enum_character_state_character_state_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool character_state_character_state_enum_IsValid(int value);
constexpr character_state_character_state_enum character_state_character_state_enum_character_state_enum_MIN = character_state_character_state_enum_NONE;
constexpr character_state_character_state_enum character_state_character_state_enum_character_state_enum_MAX = character_state_character_state_enum_COMBAT;
constexpr int character_state_character_state_enum_character_state_enum_ARRAYSIZE = character_state_character_state_enum_character_state_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* character_state_character_state_enum_descriptor();
template<typename T>
inline const std::string& character_state_character_state_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, character_state_character_state_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function character_state_character_state_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    character_state_character_state_enum_descriptor(), enum_t_value);
}
inline bool character_state_character_state_enum_Parse(
    const std::string& name, character_state_character_state_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<character_state_character_state_enum>(
    character_state_character_state_enum_descriptor(), name, value);
}
enum tile_tile_type : int {
  tile_tile_type_EMPTY = 0,
  tile_tile_type_WALL = 1,
  tile_tile_type_TREE = 2,
  tile_tile_type_PORTAL = 3,
  tile_tile_type_tile_tile_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  tile_tile_type_tile_tile_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool tile_tile_type_IsValid(int value);
constexpr tile_tile_type tile_tile_type_tile_type_MIN = tile_tile_type_EMPTY;
constexpr tile_tile_type tile_tile_type_tile_type_MAX = tile_tile_type_PORTAL;
constexpr int tile_tile_type_tile_type_ARRAYSIZE = tile_tile_type_tile_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* tile_tile_type_descriptor();
template<typename T>
inline const std::string& tile_tile_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, tile_tile_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function tile_tile_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    tile_tile_type_descriptor(), enum_t_value);
}
inline bool tile_tile_type_Parse(
    const std::string& name, tile_tile_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<tile_tile_type>(
    tile_tile_type_descriptor(), name, value);
}
enum tile_resident_type : int {
  tile_resident_type_NOBODY = 0,
  tile_resident_type_CHARACTER = 1,
  tile_resident_type_ENEMY = 2,
  tile_resident_type_tile_resident_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  tile_resident_type_tile_resident_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool tile_resident_type_IsValid(int value);
constexpr tile_resident_type tile_resident_type_resident_type_MIN = tile_resident_type_NOBODY;
constexpr tile_resident_type tile_resident_type_resident_type_MAX = tile_resident_type_ENEMY;
constexpr int tile_resident_type_resident_type_ARRAYSIZE = tile_resident_type_resident_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* tile_resident_type_descriptor();
template<typename T>
inline const std::string& tile_resident_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, tile_resident_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function tile_resident_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    tile_resident_type_descriptor(), enum_t_value);
}
inline bool tile_resident_type_Parse(
    const std::string& name, tile_resident_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<tile_resident_type>(
    tile_resident_type_descriptor(), name, value);
}
enum login_out_login_state_enum : int {
  login_out_login_state_enum_OK = 0,
  login_out_login_state_enum_FAILED = 1,
  login_out_login_state_enum_login_out_login_state_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  login_out_login_state_enum_login_out_login_state_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool login_out_login_state_enum_IsValid(int value);
constexpr login_out_login_state_enum login_out_login_state_enum_login_state_enum_MIN = login_out_login_state_enum_OK;
constexpr login_out_login_state_enum login_out_login_state_enum_login_state_enum_MAX = login_out_login_state_enum_FAILED;
constexpr int login_out_login_state_enum_login_state_enum_ARRAYSIZE = login_out_login_state_enum_login_state_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* login_out_login_state_enum_descriptor();
template<typename T>
inline const std::string& login_out_login_state_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, login_out_login_state_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function login_out_login_state_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    login_out_login_state_enum_descriptor(), enum_t_value);
}
inline bool login_out_login_state_enum_Parse(
    const std::string& name, login_out_login_state_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<login_out_login_state_enum>(
    login_out_login_state_enum_descriptor(), name, value);
}
enum select_character_in_action_type : int {
  select_character_in_action_type_SELECT = 0,
  select_character_in_action_type_CREATE = 1,
  select_character_in_action_type_select_character_in_action_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  select_character_in_action_type_select_character_in_action_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool select_character_in_action_type_IsValid(int value);
constexpr select_character_in_action_type select_character_in_action_type_action_type_MIN = select_character_in_action_type_SELECT;
constexpr select_character_in_action_type select_character_in_action_type_action_type_MAX = select_character_in_action_type_CREATE;
constexpr int select_character_in_action_type_action_type_ARRAYSIZE = select_character_in_action_type_action_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* select_character_in_action_type_descriptor();
template<typename T>
inline const std::string& select_character_in_action_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, select_character_in_action_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function select_character_in_action_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    select_character_in_action_type_descriptor(), enum_t_value);
}
inline bool select_character_in_action_type_Parse(
    const std::string& name, select_character_in_action_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<select_character_in_action_type>(
    select_character_in_action_type_descriptor(), name, value);
}
enum select_character_out_result_enum : int {
  select_character_out_result_enum_OK = 0,
  select_character_out_result_enum_NOT_FOUND = 1,
  select_character_out_result_enum_NAME_ALREADY_EXIST = 2,
  select_character_out_result_enum_TILE_OCCUPED = 3,
  select_character_out_result_enum_select_character_out_result_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  select_character_out_result_enum_select_character_out_result_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool select_character_out_result_enum_IsValid(int value);
constexpr select_character_out_result_enum select_character_out_result_enum_result_enum_MIN = select_character_out_result_enum_OK;
constexpr select_character_out_result_enum select_character_out_result_enum_result_enum_MAX = select_character_out_result_enum_TILE_OCCUPED;
constexpr int select_character_out_result_enum_result_enum_ARRAYSIZE = select_character_out_result_enum_result_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* select_character_out_result_enum_descriptor();
template<typename T>
inline const std::string& select_character_out_result_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, select_character_out_result_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function select_character_out_result_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    select_character_out_result_enum_descriptor(), enum_t_value);
}
inline bool select_character_out_result_enum_Parse(
    const std::string& name, select_character_out_result_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<select_character_out_result_enum>(
    select_character_out_result_enum_descriptor(), name, value);
}
enum play_in_input_enum : int {
  play_in_input_enum_NONE = 0,
  play_in_input_enum_FORWARD = 1,
  play_in_input_enum_BACKWARD = 2,
  play_in_input_enum_LEFT = 3,
  play_in_input_enum_RIGHT = 4,
  play_in_input_enum_ATTACK = 5,
  play_in_input_enum_QUIT = 6,
  play_in_input_enum_INFO = 7,
  play_in_input_enum_PRINT = 8,
  play_in_input_enum_play_in_input_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  play_in_input_enum_play_in_input_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool play_in_input_enum_IsValid(int value);
constexpr play_in_input_enum play_in_input_enum_input_enum_MIN = play_in_input_enum_NONE;
constexpr play_in_input_enum play_in_input_enum_input_enum_MAX = play_in_input_enum_PRINT;
constexpr int play_in_input_enum_input_enum_ARRAYSIZE = play_in_input_enum_input_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* play_in_input_enum_descriptor();
template<typename T>
inline const std::string& play_in_input_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, play_in_input_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function play_in_input_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    play_in_input_enum_descriptor(), enum_t_value);
}
inline bool play_in_input_enum_Parse(
    const std::string& name, play_in_input_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<play_in_input_enum>(
    play_in_input_enum_descriptor(), name, value);
}
enum play_out_status_enum : int {
  play_out_status_enum_FAILURE = 0,
  play_out_status_enum_SUCCESS = 1,
  play_out_status_enum_QUIT = 2,
  play_out_status_enum_DEAD = 3,
  play_out_status_enum_play_out_status_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  play_out_status_enum_play_out_status_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool play_out_status_enum_IsValid(int value);
constexpr play_out_status_enum play_out_status_enum_status_enum_MIN = play_out_status_enum_FAILURE;
constexpr play_out_status_enum play_out_status_enum_status_enum_MAX = play_out_status_enum_DEAD;
constexpr int play_out_status_enum_status_enum_ARRAYSIZE = play_out_status_enum_status_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* play_out_status_enum_descriptor();
template<typename T>
inline const std::string& play_out_status_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, play_out_status_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function play_out_status_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    play_out_status_enum_descriptor(), enum_t_value);
}
inline bool play_out_status_enum_Parse(
    const std::string& name, play_out_status_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<play_out_status_enum>(
    play_out_status_enum_descriptor(), name, value);
}
// ===================================================================

class player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player) */ {
 public:
  player();
  virtual ~player();

  player(const player& from);
  player(player&& from) noexcept
    : player() {
    *this = ::std::move(from);
  }

  inline player& operator=(const player& from) {
    CopyFrom(from);
    return *this;
  }
  inline player& operator=(player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player* internal_default_instance() {
    return reinterpret_cast<const player*>(
               &_player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(player& a, player& b) {
    a.Swap(&b);
  }
  inline void Swap(player* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player* New() const final {
    return CreateMaybeMessage<player>(nullptr);
  }

  player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player& from);
  void MergeFrom(const player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdCharactersFieldNumber = 4,
    kNameFieldNumber = 1,
    kPasswordHashFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // repeated int64 idCharacters = 4;
  int idcharacters_size() const;
  private:
  int _internal_idcharacters_size() const;
  public:
  void clear_idcharacters();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_idcharacters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_idcharacters() const;
  void _internal_add_idcharacters(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_idcharacters();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 idcharacters(int index) const;
  void set_idcharacters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_idcharacters(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      idcharacters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_idcharacters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string passwordHash = 2;
  void clear_passwordhash();
  const std::string& passwordhash() const;
  void set_passwordhash(const std::string& value);
  void set_passwordhash(std::string&& value);
  void set_passwordhash(const char* value);
  void set_passwordhash(const char* value, size_t size);
  std::string* mutable_passwordhash();
  std::string* release_passwordhash();
  void set_allocated_passwordhash(std::string* passwordhash);
  private:
  const std::string& _internal_passwordhash() const;
  void _internal_set_passwordhash(const std::string& value);
  std::string* _internal_mutable_passwordhash();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.player)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > idcharacters_;
  mutable std::atomic<int> _idcharacters_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwordhash_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class player_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player_book) */ {
 public:
  player_book();
  virtual ~player_book();

  player_book(const player_book& from);
  player_book(player_book&& from) noexcept
    : player_book() {
    *this = ::std::move(from);
  }

  inline player_book& operator=(const player_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline player_book& operator=(player_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player_book* internal_default_instance() {
    return reinterpret_cast<const player_book*>(
               &_player_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(player_book& a, player_book& b) {
    a.Swap(&b);
  }
  inline void Swap(player_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player_book* New() const final {
    return CreateMaybeMessage<player_book>(nullptr);
  }

  player_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player_book& from);
  void MergeFrom(const player_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .mud.player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::mud::player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
      mutable_players();
  private:
  const ::mud::player& _internal_players(int index) const;
  ::mud::player* _internal_add_players();
  public:
  const ::mud::player& players(int index) const;
  ::mud::player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
      players() const;

  // @@protoc_insertion_point(class_scope:mud.player_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.direction) */ {
 public:
  direction();
  virtual ~direction();

  direction(const direction& from);
  direction(direction&& from) noexcept
    : direction() {
    *this = ::std::move(from);
  }

  inline direction& operator=(const direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline direction& operator=(direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const direction* internal_default_instance() {
    return reinterpret_cast<const direction*>(
               &_direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(direction& a, direction& b) {
    a.Swap(&b);
  }
  inline void Swap(direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline direction* New() const final {
    return CreateMaybeMessage<direction>(nullptr);
  }

  direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const direction& from);
  void MergeFrom(const direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef direction_direction_enum direction_enum;
  static constexpr direction_enum NORTH =
    direction_direction_enum_NORTH;
  static constexpr direction_enum SOUTH =
    direction_direction_enum_SOUTH;
  static constexpr direction_enum EAST =
    direction_direction_enum_EAST;
  static constexpr direction_enum WEST =
    direction_direction_enum_WEST;
  static inline bool direction_enum_IsValid(int value) {
    return direction_direction_enum_IsValid(value);
  }
  static constexpr direction_enum direction_enum_MIN =
    direction_direction_enum_direction_enum_MIN;
  static constexpr direction_enum direction_enum_MAX =
    direction_direction_enum_direction_enum_MAX;
  static constexpr int direction_enum_ARRAYSIZE =
    direction_direction_enum_direction_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  direction_enum_descriptor() {
    return direction_direction_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& direction_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, direction_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function direction_enum_Name.");
    return direction_direction_enum_Name(enum_t_value);
  }
  static inline bool direction_enum_Parse(const std::string& name,
      direction_enum* value) {
    return direction_direction_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .mud.direction.direction_enum value = 1;
  void clear_value();
  ::mud::direction_direction_enum value() const;
  void set_value(::mud::direction_direction_enum value);
  private:
  ::mud::direction_direction_enum _internal_value() const;
  void _internal_set_value(::mud::direction_direction_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class attribute :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.attribute) */ {
 public:
  attribute();
  virtual ~attribute();

  attribute(const attribute& from);
  attribute(attribute&& from) noexcept
    : attribute() {
    *this = ::std::move(from);
  }

  inline attribute& operator=(const attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline attribute& operator=(attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const attribute* internal_default_instance() {
    return reinterpret_cast<const attribute*>(
               &_attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(attribute& a, attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(attribute* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline attribute* New() const final {
    return CreateMaybeMessage<attribute>(nullptr);
  }

  attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<attribute>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const attribute& from);
  void MergeFrom(const attribute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(attribute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.attribute";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef attribute_attribute_name attribute_name;
  static constexpr attribute_name LIFE =
    attribute_attribute_name_LIFE;
  static constexpr attribute_name STRENGTH =
    attribute_attribute_name_STRENGTH;
  static constexpr attribute_name AGILITY =
    attribute_attribute_name_AGILITY;
  static constexpr attribute_name INTELLIGENCE =
    attribute_attribute_name_INTELLIGENCE;
  static inline bool attribute_name_IsValid(int value) {
    return attribute_attribute_name_IsValid(value);
  }
  static constexpr attribute_name attribute_name_MIN =
    attribute_attribute_name_attribute_name_MIN;
  static constexpr attribute_name attribute_name_MAX =
    attribute_attribute_name_attribute_name_MAX;
  static constexpr int attribute_name_ARRAYSIZE =
    attribute_attribute_name_attribute_name_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  attribute_name_descriptor() {
    return attribute_attribute_name_descriptor();
  }
  template<typename T>
  static inline const std::string& attribute_name_Name(T enum_t_value) {
    static_assert(::std::is_same<T, attribute_name>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function attribute_name_Name.");
    return attribute_attribute_name_Name(enum_t_value);
  }
  static inline bool attribute_name_Parse(const std::string& name,
      attribute_name* value) {
    return attribute_attribute_name_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kRegenFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // int64 value = 2;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 regen = 3;
  void clear_regen();
  ::PROTOBUF_NAMESPACE_ID::int64 regen() const;
  void set_regen(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_regen() const;
  void _internal_set_regen(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.attribute.attribute_name name = 1;
  void clear_name();
  ::mud::attribute_attribute_name name() const;
  void set_name(::mud::attribute_attribute_name value);
  private:
  ::mud::attribute_attribute_name _internal_name() const;
  void _internal_set_name(::mud::attribute_attribute_name value);
  public:

  // @@protoc_insertion_point(class_scope:mud.attribute)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  ::PROTOBUF_NAMESPACE_ID::int64 regen_;
  int name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character_state :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character_state) */ {
 public:
  character_state();
  virtual ~character_state();

  character_state(const character_state& from);
  character_state(character_state&& from) noexcept
    : character_state() {
    *this = ::std::move(from);
  }

  inline character_state& operator=(const character_state& from) {
    CopyFrom(from);
    return *this;
  }
  inline character_state& operator=(character_state&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character_state& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character_state* internal_default_instance() {
    return reinterpret_cast<const character_state*>(
               &_character_state_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(character_state& a, character_state& b) {
    a.Swap(&b);
  }
  inline void Swap(character_state* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character_state* New() const final {
    return CreateMaybeMessage<character_state>(nullptr);
  }

  character_state* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character_state>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character_state& from);
  void MergeFrom(const character_state& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character_state* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character_state";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef character_state_character_state_enum character_state_enum;
  static constexpr character_state_enum NONE =
    character_state_character_state_enum_NONE;
  static constexpr character_state_enum WALKING =
    character_state_character_state_enum_WALKING;
  static constexpr character_state_enum COMBAT =
    character_state_character_state_enum_COMBAT;
  static inline bool character_state_enum_IsValid(int value) {
    return character_state_character_state_enum_IsValid(value);
  }
  static constexpr character_state_enum character_state_enum_MIN =
    character_state_character_state_enum_character_state_enum_MIN;
  static constexpr character_state_enum character_state_enum_MAX =
    character_state_character_state_enum_character_state_enum_MAX;
  static constexpr int character_state_enum_ARRAYSIZE =
    character_state_character_state_enum_character_state_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  character_state_enum_descriptor() {
    return character_state_character_state_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& character_state_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, character_state_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function character_state_enum_Name.");
    return character_state_character_state_enum_Name(enum_t_value);
  }
  static inline bool character_state_enum_Parse(const std::string& name,
      character_state_enum* value) {
    return character_state_character_state_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .mud.character_state.character_state_enum value = 1;
  void clear_value();
  ::mud::character_state_character_state_enum value() const;
  void set_value(::mud::character_state_character_state_enum value);
  private:
  ::mud::character_state_character_state_enum _internal_value() const;
  void _internal_set_value(::mud::character_state_character_state_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.character_state)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character) */ {
 public:
  character();
  virtual ~character();

  character(const character& from);
  character(character&& from) noexcept
    : character() {
    *this = ::std::move(from);
  }

  inline character& operator=(const character& from) {
    CopyFrom(from);
    return *this;
  }
  inline character& operator=(character&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character* internal_default_instance() {
    return reinterpret_cast<const character*>(
               &_character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(character& a, character& b) {
    a.Swap(&b);
  }
  inline void Swap(character* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character* New() const final {
    return CreateMaybeMessage<character>(nullptr);
  }

  character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character& from);
  void MergeFrom(const character& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kStateFieldNumber = 6,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
  };
  // repeated .mud.attribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
      mutable_attributes();
  private:
  const ::mud::attribute& _internal_attributes(int index) const;
  ::mud::attribute* _internal_add_attributes();
  public:
  const ::mud::attribute& attributes(int index) const;
  ::mud::attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::direction& facing() const;
  ::mud::direction* release_facing();
  ::mud::direction* mutable_facing();
  void set_allocated_facing(::mud::direction* facing);
  private:
  const ::mud::direction& _internal_facing() const;
  ::mud::direction* _internal_mutable_facing();
  public:

  // .mud.character_state state = 6;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::mud::character_state& state() const;
  ::mud::character_state* release_state();
  ::mud::character_state* mutable_state();
  void set_allocated_state(::mud::character_state* state);
  private:
  const ::mud::character_state& _internal_state() const;
  ::mud::character_state* _internal_mutable_state();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.character)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::direction* facing_;
  ::mud::character_state* state_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy) */ {
 public:
  enemy();
  virtual ~enemy();

  enemy(const enemy& from);
  enemy(enemy&& from) noexcept
    : enemy() {
    *this = ::std::move(from);
  }

  inline enemy& operator=(const enemy& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy& operator=(enemy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy* internal_default_instance() {
    return reinterpret_cast<const enemy*>(
               &_enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(enemy& a, enemy& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy* New() const final {
    return CreateMaybeMessage<enemy>(nullptr);
  }

  enemy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy& from);
  void MergeFrom(const enemy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kStateFieldNumber = 6,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
  };
  // repeated .mud.attribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
      mutable_attributes();
  private:
  const ::mud::attribute& _internal_attributes(int index) const;
  ::mud::attribute* _internal_add_attributes();
  public:
  const ::mud::attribute& attributes(int index) const;
  ::mud::attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::direction& facing() const;
  ::mud::direction* release_facing();
  ::mud::direction* mutable_facing();
  void set_allocated_facing(::mud::direction* facing);
  private:
  const ::mud::direction& _internal_facing() const;
  ::mud::direction* _internal_mutable_facing();
  public:

  // .mud.character_state state = 6;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::mud::character_state& state() const;
  ::mud::character_state* release_state();
  ::mud::character_state* mutable_state();
  void set_allocated_state(::mud::character_state* state);
  private:
  const ::mud::character_state& _internal_state() const;
  ::mud::character_state* _internal_mutable_state();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.enemy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::direction* facing_;
  ::mud::character_state* state_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character_book) */ {
 public:
  character_book();
  virtual ~character_book();

  character_book(const character_book& from);
  character_book(character_book&& from) noexcept
    : character_book() {
    *this = ::std::move(from);
  }

  inline character_book& operator=(const character_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline character_book& operator=(character_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character_book* internal_default_instance() {
    return reinterpret_cast<const character_book*>(
               &_character_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(character_book& a, character_book& b) {
    a.Swap(&b);
  }
  inline void Swap(character_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character_book* New() const final {
    return CreateMaybeMessage<character_book>(nullptr);
  }

  character_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character_book& from);
  void MergeFrom(const character_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .mud.character characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // @@protoc_insertion_point(class_scope:mud.character_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy_book) */ {
 public:
  enemy_book();
  virtual ~enemy_book();

  enemy_book(const enemy_book& from);
  enemy_book(enemy_book&& from) noexcept
    : enemy_book() {
    *this = ::std::move(from);
  }

  inline enemy_book& operator=(const enemy_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy_book& operator=(enemy_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy_book* internal_default_instance() {
    return reinterpret_cast<const enemy_book*>(
               &_enemy_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(enemy_book& a, enemy_book& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy_book* New() const final {
    return CreateMaybeMessage<enemy_book>(nullptr);
  }

  enemy_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy_book& from);
  void MergeFrom(const enemy_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnemiesFieldNumber = 1,
  };
  // repeated .mud.enemy enemies = 1;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::mud::enemy* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
      mutable_enemies();
  private:
  const ::mud::enemy& _internal_enemies(int index) const;
  ::mud::enemy* _internal_add_enemies();
  public:
  const ::mud::enemy& enemies(int index) const;
  ::mud::enemy* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
      enemies() const;

  // @@protoc_insertion_point(class_scope:mud.enemy_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy > enemies_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class neighbour :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.neighbour) */ {
 public:
  neighbour();
  virtual ~neighbour();

  neighbour(const neighbour& from);
  neighbour(neighbour&& from) noexcept
    : neighbour() {
    *this = ::std::move(from);
  }

  inline neighbour& operator=(const neighbour& from) {
    CopyFrom(from);
    return *this;
  }
  inline neighbour& operator=(neighbour&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const neighbour& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const neighbour* internal_default_instance() {
    return reinterpret_cast<const neighbour*>(
               &_neighbour_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(neighbour& a, neighbour& b) {
    a.Swap(&b);
  }
  inline void Swap(neighbour* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline neighbour* New() const final {
    return CreateMaybeMessage<neighbour>(nullptr);
  }

  neighbour* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<neighbour>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const neighbour& from);
  void MergeFrom(const neighbour& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(neighbour* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.neighbour";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeighbourDirectionFieldNumber = 1,
    kNeighbourTileIdFieldNumber = 2,
  };
  // .mud.direction neighbour_direction = 1;
  bool has_neighbour_direction() const;
  private:
  bool _internal_has_neighbour_direction() const;
  public:
  void clear_neighbour_direction();
  const ::mud::direction& neighbour_direction() const;
  ::mud::direction* release_neighbour_direction();
  ::mud::direction* mutable_neighbour_direction();
  void set_allocated_neighbour_direction(::mud::direction* neighbour_direction);
  private:
  const ::mud::direction& _internal_neighbour_direction() const;
  ::mud::direction* _internal_mutable_neighbour_direction();
  public:

  // int64 neighbour_tile_id = 2;
  void clear_neighbour_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 neighbour_tile_id() const;
  void set_neighbour_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_neighbour_tile_id() const;
  void _internal_set_neighbour_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.neighbour)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mud::direction* neighbour_direction_;
  ::PROTOBUF_NAMESPACE_ID::int64 neighbour_tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile) */ {
 public:
  tile();
  virtual ~tile();

  tile(const tile& from);
  tile(tile&& from) noexcept
    : tile() {
    *this = ::std::move(from);
  }

  inline tile& operator=(const tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile& operator=(tile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile* internal_default_instance() {
    return reinterpret_cast<const tile*>(
               &_tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(tile& a, tile& b) {
    a.Swap(&b);
  }
  inline void Swap(tile* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile* New() const final {
    return CreateMaybeMessage<tile>(nullptr);
  }

  tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile& from);
  void MergeFrom(const tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef tile_tile_type tile_type;
  static constexpr tile_type EMPTY =
    tile_tile_type_EMPTY;
  static constexpr tile_type WALL =
    tile_tile_type_WALL;
  static constexpr tile_type TREE =
    tile_tile_type_TREE;
  static constexpr tile_type PORTAL =
    tile_tile_type_PORTAL;
  static inline bool tile_type_IsValid(int value) {
    return tile_tile_type_IsValid(value);
  }
  static constexpr tile_type tile_type_MIN =
    tile_tile_type_tile_type_MIN;
  static constexpr tile_type tile_type_MAX =
    tile_tile_type_tile_type_MAX;
  static constexpr int tile_type_ARRAYSIZE =
    tile_tile_type_tile_type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  tile_type_descriptor() {
    return tile_tile_type_descriptor();
  }
  template<typename T>
  static inline const std::string& tile_type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, tile_type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function tile_type_Name.");
    return tile_tile_type_Name(enum_t_value);
  }
  static inline bool tile_type_Parse(const std::string& name,
      tile_type* value) {
    return tile_tile_type_Parse(name, value);
  }

  typedef tile_resident_type resident_type;
  static constexpr resident_type NOBODY =
    tile_resident_type_NOBODY;
  static constexpr resident_type CHARACTER =
    tile_resident_type_CHARACTER;
  static constexpr resident_type ENEMY =
    tile_resident_type_ENEMY;
  static inline bool resident_type_IsValid(int value) {
    return tile_resident_type_IsValid(value);
  }
  static constexpr resident_type resident_type_MIN =
    tile_resident_type_resident_type_MIN;
  static constexpr resident_type resident_type_MAX =
    tile_resident_type_resident_type_MAX;
  static constexpr int resident_type_ARRAYSIZE =
    tile_resident_type_resident_type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  resident_type_descriptor() {
    return tile_resident_type_descriptor();
  }
  template<typename T>
  static inline const std::string& resident_type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, resident_type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function resident_type_Name.");
    return tile_resident_type_Name(enum_t_value);
  }
  static inline bool resident_type_Parse(const std::string& name,
      resident_type* value) {
    return tile_resident_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNeighboursFieldNumber = 3,
    kMoodFieldNumber = 6,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOccupantTypeFieldNumber = 4,
    kOccupantIdFieldNumber = 5,
  };
  // repeated .mud.neighbour neighbours = 3;
  int neighbours_size() const;
  private:
  int _internal_neighbours_size() const;
  public:
  void clear_neighbours();
  ::mud::neighbour* mutable_neighbours(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::neighbour >*
      mutable_neighbours();
  private:
  const ::mud::neighbour& _internal_neighbours(int index) const;
  ::mud::neighbour* _internal_add_neighbours();
  public:
  const ::mud::neighbour& neighbours(int index) const;
  ::mud::neighbour* add_neighbours();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::neighbour >&
      neighbours() const;

  // string mood = 6;
  void clear_mood();
  const std::string& mood() const;
  void set_mood(const std::string& value);
  void set_mood(std::string&& value);
  void set_mood(const char* value);
  void set_mood(const char* value, size_t size);
  std::string* mutable_mood();
  std::string* release_mood();
  void set_allocated_mood(std::string* mood);
  private:
  const std::string& _internal_mood() const;
  void _internal_set_mood(const std::string& value);
  std::string* _internal_mutable_mood();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.tile.tile_type type = 2;
  void clear_type();
  ::mud::tile_tile_type type() const;
  void set_type(::mud::tile_tile_type value);
  private:
  ::mud::tile_tile_type _internal_type() const;
  void _internal_set_type(::mud::tile_tile_type value);
  public:

  // .mud.tile.resident_type occupant_type = 4;
  void clear_occupant_type();
  ::mud::tile_resident_type occupant_type() const;
  void set_occupant_type(::mud::tile_resident_type value);
  private:
  ::mud::tile_resident_type _internal_occupant_type() const;
  void _internal_set_occupant_type(::mud::tile_resident_type value);
  public:

  // int64 occupant_id = 5;
  void clear_occupant_id();
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id() const;
  void set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_occupant_id() const;
  void _internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.tile)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::neighbour > neighbours_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mood_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int type_;
  int occupant_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile_book) */ {
 public:
  tile_book();
  virtual ~tile_book();

  tile_book(const tile_book& from);
  tile_book(tile_book&& from) noexcept
    : tile_book() {
    *this = ::std::move(from);
  }

  inline tile_book& operator=(const tile_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile_book& operator=(tile_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile_book* internal_default_instance() {
    return reinterpret_cast<const tile_book*>(
               &_tile_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(tile_book& a, tile_book& b) {
    a.Swap(&b);
  }
  inline void Swap(tile_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile_book* New() const final {
    return CreateMaybeMessage<tile_book>(nullptr);
  }

  tile_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile_book& from);
  void MergeFrom(const tile_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .mud.tile tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::mud::tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
      mutable_tiles();
  private:
  const ::mud::tile& _internal_tiles(int index) const;
  ::mud::tile* _internal_add_tiles();
  public:
  const ::mud::tile& tiles(int index) const;
  ::mud::tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:mud.tile_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile > tiles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class token_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.token_in) */ {
 public:
  token_in();
  virtual ~token_in();

  token_in(const token_in& from);
  token_in(token_in&& from) noexcept
    : token_in() {
    *this = ::std::move(from);
  }

  inline token_in& operator=(const token_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline token_in& operator=(token_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const token_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const token_in* internal_default_instance() {
    return reinterpret_cast<const token_in*>(
               &_token_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(token_in& a, token_in& b) {
    a.Swap(&b);
  }
  inline void Swap(token_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline token_in* New() const final {
    return CreateMaybeMessage<token_in>(nullptr);
  }

  token_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<token_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const token_in& from);
  void MergeFrom(const token_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(token_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.token_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mud.token_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class token_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.token_out) */ {
 public:
  token_out();
  virtual ~token_out();

  token_out(const token_out& from);
  token_out(token_out&& from) noexcept
    : token_out() {
    *this = ::std::move(from);
  }

  inline token_out& operator=(const token_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline token_out& operator=(token_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const token_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const token_out* internal_default_instance() {
    return reinterpret_cast<const token_out*>(
               &_token_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(token_out& a, token_out& b) {
    a.Swap(&b);
  }
  inline void Swap(token_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline token_out* New() const final {
    return CreateMaybeMessage<token_out>(nullptr);
  }

  token_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<token_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const token_out& from);
  void MergeFrom(const token_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(token_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.token_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // int64 token = 1;
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.token_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class login_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.login_in) */ {
 public:
  login_in();
  virtual ~login_in();

  login_in(const login_in& from);
  login_in(login_in&& from) noexcept
    : login_in() {
    *this = ::std::move(from);
  }

  inline login_in& operator=(const login_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_in& operator=(login_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_in* internal_default_instance() {
    return reinterpret_cast<const login_in*>(
               &_login_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(login_in& a, login_in& b) {
    a.Swap(&b);
  }
  inline void Swap(login_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_in* New() const final {
    return CreateMaybeMessage<login_in>(nullptr);
  }

  login_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_in& from);
  void MergeFrom(const login_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.login_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kHashFieldNumber = 2,
    kTokenFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // int64 token = 3;
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.login_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class login_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.login_out) */ {
 public:
  login_out();
  virtual ~login_out();

  login_out(const login_out& from);
  login_out(login_out&& from) noexcept
    : login_out() {
    *this = ::std::move(from);
  }

  inline login_out& operator=(const login_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_out& operator=(login_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_out* internal_default_instance() {
    return reinterpret_cast<const login_out*>(
               &_login_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(login_out& a, login_out& b) {
    a.Swap(&b);
  }
  inline void Swap(login_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_out* New() const final {
    return CreateMaybeMessage<login_out>(nullptr);
  }

  login_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_out& from);
  void MergeFrom(const login_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.login_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef login_out_login_state_enum login_state_enum;
  static constexpr login_state_enum OK =
    login_out_login_state_enum_OK;
  static constexpr login_state_enum FAILED =
    login_out_login_state_enum_FAILED;
  static inline bool login_state_enum_IsValid(int value) {
    return login_out_login_state_enum_IsValid(value);
  }
  static constexpr login_state_enum login_state_enum_MIN =
    login_out_login_state_enum_login_state_enum_MIN;
  static constexpr login_state_enum login_state_enum_MAX =
    login_out_login_state_enum_login_state_enum_MAX;
  static constexpr int login_state_enum_ARRAYSIZE =
    login_out_login_state_enum_login_state_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  login_state_enum_descriptor() {
    return login_out_login_state_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& login_state_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, login_state_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function login_state_enum_Name.");
    return login_out_login_state_enum_Name(enum_t_value);
  }
  static inline bool login_state_enum_Parse(const std::string& name,
      login_state_enum* value) {
    return login_out_login_state_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
    kLoginStateFieldNumber = 2,
  };
  // repeated .mud.character characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // .mud.login_out.login_state_enum login_state = 2;
  void clear_login_state();
  ::mud::login_out_login_state_enum login_state() const;
  void set_login_state(::mud::login_out_login_state_enum value);
  private:
  ::mud::login_out_login_state_enum _internal_login_state() const;
  void _internal_set_login_state(::mud::login_out_login_state_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.login_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  int login_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class select_character_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.select_character_in) */ {
 public:
  select_character_in();
  virtual ~select_character_in();

  select_character_in(const select_character_in& from);
  select_character_in(select_character_in&& from) noexcept
    : select_character_in() {
    *this = ::std::move(from);
  }

  inline select_character_in& operator=(const select_character_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline select_character_in& operator=(select_character_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const select_character_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const select_character_in* internal_default_instance() {
    return reinterpret_cast<const select_character_in*>(
               &_select_character_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(select_character_in& a, select_character_in& b) {
    a.Swap(&b);
  }
  inline void Swap(select_character_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline select_character_in* New() const final {
    return CreateMaybeMessage<select_character_in>(nullptr);
  }

  select_character_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<select_character_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const select_character_in& from);
  void MergeFrom(const select_character_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(select_character_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.select_character_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef select_character_in_action_type action_type;
  static constexpr action_type SELECT =
    select_character_in_action_type_SELECT;
  static constexpr action_type CREATE =
    select_character_in_action_type_CREATE;
  static inline bool action_type_IsValid(int value) {
    return select_character_in_action_type_IsValid(value);
  }
  static constexpr action_type action_type_MIN =
    select_character_in_action_type_action_type_MIN;
  static constexpr action_type action_type_MAX =
    select_character_in_action_type_action_type_MAX;
  static constexpr int action_type_ARRAYSIZE =
    select_character_in_action_type_action_type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  action_type_descriptor() {
    return select_character_in_action_type_descriptor();
  }
  template<typename T>
  static inline const std::string& action_type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, action_type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function action_type_Name.");
    return select_character_in_action_type_Name(enum_t_value);
  }
  static inline bool action_type_Parse(const std::string& name,
      action_type* value) {
    return select_character_in_action_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTokenFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 token = 2;
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.select_character_in.action_type action = 3;
  void clear_action();
  ::mud::select_character_in_action_type action() const;
  void set_action(::mud::select_character_in_action_type value);
  private:
  ::mud::select_character_in_action_type _internal_action() const;
  void _internal_set_action(::mud::select_character_in_action_type value);
  public:

  // @@protoc_insertion_point(class_scope:mud.select_character_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class select_character_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.select_character_out) */ {
 public:
  select_character_out();
  virtual ~select_character_out();

  select_character_out(const select_character_out& from);
  select_character_out(select_character_out&& from) noexcept
    : select_character_out() {
    *this = ::std::move(from);
  }

  inline select_character_out& operator=(const select_character_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline select_character_out& operator=(select_character_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const select_character_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const select_character_out* internal_default_instance() {
    return reinterpret_cast<const select_character_out*>(
               &_select_character_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(select_character_out& a, select_character_out& b) {
    a.Swap(&b);
  }
  inline void Swap(select_character_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline select_character_out* New() const final {
    return CreateMaybeMessage<select_character_out>(nullptr);
  }

  select_character_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<select_character_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const select_character_out& from);
  void MergeFrom(const select_character_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(select_character_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.select_character_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef select_character_out_result_enum result_enum;
  static constexpr result_enum OK =
    select_character_out_result_enum_OK;
  static constexpr result_enum NOT_FOUND =
    select_character_out_result_enum_NOT_FOUND;
  static constexpr result_enum NAME_ALREADY_EXIST =
    select_character_out_result_enum_NAME_ALREADY_EXIST;
  static constexpr result_enum TILE_OCCUPED =
    select_character_out_result_enum_TILE_OCCUPED;
  static inline bool result_enum_IsValid(int value) {
    return select_character_out_result_enum_IsValid(value);
  }
  static constexpr result_enum result_enum_MIN =
    select_character_out_result_enum_result_enum_MIN;
  static constexpr result_enum result_enum_MAX =
    select_character_out_result_enum_result_enum_MAX;
  static constexpr int result_enum_ARRAYSIZE =
    select_character_out_result_enum_result_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  result_enum_descriptor() {
    return select_character_out_result_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& result_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, result_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function result_enum_Name.");
    return select_character_out_result_enum_Name(enum_t_value);
  }
  static inline bool result_enum_Parse(const std::string& name,
      result_enum* value) {
    return select_character_out_result_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedCharacterFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // .mud.character selected_character = 1;
  bool has_selected_character() const;
  private:
  bool _internal_has_selected_character() const;
  public:
  void clear_selected_character();
  const ::mud::character& selected_character() const;
  ::mud::character* release_selected_character();
  ::mud::character* mutable_selected_character();
  void set_allocated_selected_character(::mud::character* selected_character);
  private:
  const ::mud::character& _internal_selected_character() const;
  ::mud::character* _internal_mutable_selected_character();
  public:

  // .mud.select_character_out.result_enum result = 2;
  void clear_result();
  ::mud::select_character_out_result_enum result() const;
  void set_result(::mud::select_character_out_result_enum value);
  private:
  ::mud::select_character_out_result_enum _internal_result() const;
  void _internal_set_result(::mud::select_character_out_result_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.select_character_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mud::character* selected_character_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class play_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.play_in) */ {
 public:
  play_in();
  virtual ~play_in();

  play_in(const play_in& from);
  play_in(play_in&& from) noexcept
    : play_in() {
    *this = ::std::move(from);
  }

  inline play_in& operator=(const play_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline play_in& operator=(play_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const play_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const play_in* internal_default_instance() {
    return reinterpret_cast<const play_in*>(
               &_play_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(play_in& a, play_in& b) {
    a.Swap(&b);
  }
  inline void Swap(play_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline play_in* New() const final {
    return CreateMaybeMessage<play_in>(nullptr);
  }

  play_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<play_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const play_in& from);
  void MergeFrom(const play_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(play_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.play_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef play_in_input_enum input_enum;
  static constexpr input_enum NONE =
    play_in_input_enum_NONE;
  static constexpr input_enum FORWARD =
    play_in_input_enum_FORWARD;
  static constexpr input_enum BACKWARD =
    play_in_input_enum_BACKWARD;
  static constexpr input_enum LEFT =
    play_in_input_enum_LEFT;
  static constexpr input_enum RIGHT =
    play_in_input_enum_RIGHT;
  static constexpr input_enum ATTACK =
    play_in_input_enum_ATTACK;
  static constexpr input_enum QUIT =
    play_in_input_enum_QUIT;
  static constexpr input_enum INFO =
    play_in_input_enum_INFO;
  static constexpr input_enum PRINT =
    play_in_input_enum_PRINT;
  static inline bool input_enum_IsValid(int value) {
    return play_in_input_enum_IsValid(value);
  }
  static constexpr input_enum input_enum_MIN =
    play_in_input_enum_input_enum_MIN;
  static constexpr input_enum input_enum_MAX =
    play_in_input_enum_input_enum_MAX;
  static constexpr int input_enum_ARRAYSIZE =
    play_in_input_enum_input_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  input_enum_descriptor() {
    return play_in_input_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& input_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, input_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function input_enum_Name.");
    return play_in_input_enum_Name(enum_t_value);
  }
  static inline bool input_enum_Parse(const std::string& name,
      input_enum* value) {
    return play_in_input_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kCharacterIdFieldNumber = 3,
    kCommandFieldNumber = 4,
  };
  // int64 token = 1;
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 player_id = 2;
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::int64 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 character_id = 3;
  void clear_character_id();
  ::PROTOBUF_NAMESPACE_ID::int64 character_id() const;
  void set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_character_id() const;
  void _internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.play_in.input_enum command = 4;
  void clear_command();
  ::mud::play_in_input_enum command() const;
  void set_command(::mud::play_in_input_enum value);
  private:
  ::mud::play_in_input_enum _internal_command() const;
  void _internal_set_command(::mud::play_in_input_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.play_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  ::PROTOBUF_NAMESPACE_ID::int64 player_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 character_id_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class play_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.play_out) */ {
 public:
  play_out();
  virtual ~play_out();

  play_out(const play_out& from);
  play_out(play_out&& from) noexcept
    : play_out() {
    *this = ::std::move(from);
  }

  inline play_out& operator=(const play_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline play_out& operator=(play_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const play_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const play_out* internal_default_instance() {
    return reinterpret_cast<const play_out*>(
               &_play_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(play_out& a, play_out& b) {
    a.Swap(&b);
  }
  inline void Swap(play_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline play_out* New() const final {
    return CreateMaybeMessage<play_out>(nullptr);
  }

  play_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<play_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const play_out& from);
  void MergeFrom(const play_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(play_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.play_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef play_out_status_enum status_enum;
  static constexpr status_enum FAILURE =
    play_out_status_enum_FAILURE;
  static constexpr status_enum SUCCESS =
    play_out_status_enum_SUCCESS;
  static constexpr status_enum QUIT =
    play_out_status_enum_QUIT;
  static constexpr status_enum DEAD =
    play_out_status_enum_DEAD;
  static inline bool status_enum_IsValid(int value) {
    return play_out_status_enum_IsValid(value);
  }
  static constexpr status_enum status_enum_MIN =
    play_out_status_enum_status_enum_MIN;
  static constexpr status_enum status_enum_MAX =
    play_out_status_enum_status_enum_MAX;
  static constexpr int status_enum_ARRAYSIZE =
    play_out_status_enum_status_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  status_enum_descriptor() {
    return play_out_status_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& status_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, status_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function status_enum_Name.");
    return play_out_status_enum_Name(enum_t_value);
  }
  static inline bool status_enum_Parse(const std::string& name,
      status_enum* value) {
    return play_out_status_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 3,
    kCharactersFieldNumber = 4,
    kEnemiesFieldNumber = 5,
    kCharacterIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .mud.tile tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::mud::tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
      mutable_tiles();
  private:
  const ::mud::tile& _internal_tiles(int index) const;
  ::mud::tile* _internal_add_tiles();
  public:
  const ::mud::tile& tiles(int index) const;
  ::mud::tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
      tiles() const;

  // repeated .mud.character characters = 4;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // repeated .mud.enemy enemies = 5;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::mud::enemy* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
      mutable_enemies();
  private:
  const ::mud::enemy& _internal_enemies(int index) const;
  ::mud::enemy* _internal_add_enemies();
  public:
  const ::mud::enemy& enemies(int index) const;
  ::mud::enemy* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
      enemies() const;

  // int64 character_id = 1;
  void clear_character_id();
  ::PROTOBUF_NAMESPACE_ID::int64 character_id() const;
  void set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_character_id() const;
  void _internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.play_out.status_enum status = 2;
  void clear_status();
  ::mud::play_out_status_enum status() const;
  void set_status(::mud::play_out_status_enum value);
  private:
  ::mud::play_out_status_enum _internal_status() const;
  void _internal_set_status(::mud::play_out_status_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.play_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy > enemies_;
  ::PROTOBUF_NAMESPACE_ID::int64 character_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class logout_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.logout_in) */ {
 public:
  logout_in();
  virtual ~logout_in();

  logout_in(const logout_in& from);
  logout_in(logout_in&& from) noexcept
    : logout_in() {
    *this = ::std::move(from);
  }

  inline logout_in& operator=(const logout_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline logout_in& operator=(logout_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const logout_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const logout_in* internal_default_instance() {
    return reinterpret_cast<const logout_in*>(
               &_logout_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(logout_in& a, logout_in& b) {
    a.Swap(&b);
  }
  inline void Swap(logout_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline logout_in* New() const final {
    return CreateMaybeMessage<logout_in>(nullptr);
  }

  logout_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<logout_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const logout_in& from);
  void MergeFrom(const logout_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logout_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.logout_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kCharacterIdFieldNumber = 3,
  };
  // int64 token = 1;
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 player_id = 2;
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::int64 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 character_id = 3;
  void clear_character_id();
  ::PROTOBUF_NAMESPACE_ID::int64 character_id() const;
  void set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_character_id() const;
  void _internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.logout_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  ::PROTOBUF_NAMESPACE_ID::int64 player_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 character_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class logout_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.logout_out) */ {
 public:
  logout_out();
  virtual ~logout_out();

  logout_out(const logout_out& from);
  logout_out(logout_out&& from) noexcept
    : logout_out() {
    *this = ::std::move(from);
  }

  inline logout_out& operator=(const logout_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline logout_out& operator=(logout_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const logout_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const logout_out* internal_default_instance() {
    return reinterpret_cast<const logout_out*>(
               &_logout_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(logout_out& a, logout_out& b) {
    a.Swap(&b);
  }
  inline void Swap(logout_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline logout_out* New() const final {
    return CreateMaybeMessage<logout_out>(nullptr);
  }

  logout_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<logout_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const logout_out& from);
  void MergeFrom(const logout_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(logout_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.logout_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mud.logout_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// player

// string name = 1;
inline void player::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::name() const {
  // @@protoc_insertion_point(field_get:mud.player.name)
  return _internal_name();
}
inline void player::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.player.name)
}
inline std::string* player::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.player.name)
  return _internal_mutable_name();
}
inline const std::string& player::_internal_name() const {
  return name_.GetNoArena();
}
inline void player::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.name)
}
inline void player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.name)
}
inline void player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.name)
}
inline std::string* player::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_name() {
  // @@protoc_insertion_point(field_release:mud.player.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.player.name)
}

// string passwordHash = 2;
inline void player::clear_passwordhash() {
  passwordhash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::passwordhash() const {
  // @@protoc_insertion_point(field_get:mud.player.passwordHash)
  return _internal_passwordhash();
}
inline void player::set_passwordhash(const std::string& value) {
  _internal_set_passwordhash(value);
  // @@protoc_insertion_point(field_set:mud.player.passwordHash)
}
inline std::string* player::mutable_passwordhash() {
  // @@protoc_insertion_point(field_mutable:mud.player.passwordHash)
  return _internal_mutable_passwordhash();
}
inline const std::string& player::_internal_passwordhash() const {
  return passwordhash_.GetNoArena();
}
inline void player::_internal_set_passwordhash(const std::string& value) {
  
  passwordhash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_passwordhash(std::string&& value) {
  
  passwordhash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.passwordHash)
}
inline void player::set_passwordhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  passwordhash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.passwordHash)
}
inline void player::set_passwordhash(const char* value, size_t size) {
  
  passwordhash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.passwordHash)
}
inline std::string* player::_internal_mutable_passwordhash() {
  
  return passwordhash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_passwordhash() {
  // @@protoc_insertion_point(field_release:mud.player.passwordHash)
  
  return passwordhash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_passwordhash(std::string* passwordhash) {
  if (passwordhash != nullptr) {
    
  } else {
    
  }
  passwordhash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwordhash);
  // @@protoc_insertion_point(field_set_allocated:mud.player.passwordHash)
}

// int64 id = 3;
inline void player::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::id() const {
  // @@protoc_insertion_point(field_get:mud.player.id)
  return _internal_id();
}
inline void player::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void player::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.player.id)
}

// repeated int64 idCharacters = 4;
inline int player::_internal_idcharacters_size() const {
  return idcharacters_.size();
}
inline int player::idcharacters_size() const {
  return _internal_idcharacters_size();
}
inline void player::clear_idcharacters() {
  idcharacters_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_idcharacters(int index) const {
  return idcharacters_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::idcharacters(int index) const {
  // @@protoc_insertion_point(field_get:mud.player.idCharacters)
  return _internal_idcharacters(index);
}
inline void player::set_idcharacters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  idcharacters_.Set(index, value);
  // @@protoc_insertion_point(field_set:mud.player.idCharacters)
}
inline void player::_internal_add_idcharacters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  idcharacters_.Add(value);
}
inline void player::add_idcharacters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_idcharacters(value);
  // @@protoc_insertion_point(field_add:mud.player.idCharacters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::_internal_idcharacters() const {
  return idcharacters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::idcharacters() const {
  // @@protoc_insertion_point(field_list:mud.player.idCharacters)
  return _internal_idcharacters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::_internal_mutable_idcharacters() {
  return &idcharacters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::mutable_idcharacters() {
  // @@protoc_insertion_point(field_mutable_list:mud.player.idCharacters)
  return _internal_mutable_idcharacters();
}

// -------------------------------------------------------------------

// player_book

// repeated .mud.player players = 1;
inline int player_book::_internal_players_size() const {
  return players_.size();
}
inline int player_book::players_size() const {
  return _internal_players_size();
}
inline void player_book::clear_players() {
  players_.Clear();
}
inline ::mud::player* player_book::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:mud.player_book.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
player_book::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:mud.player_book.players)
  return &players_;
}
inline const ::mud::player& player_book::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::mud::player& player_book::players(int index) const {
  // @@protoc_insertion_point(field_get:mud.player_book.players)
  return _internal_players(index);
}
inline ::mud::player* player_book::_internal_add_players() {
  return players_.Add();
}
inline ::mud::player* player_book::add_players() {
  // @@protoc_insertion_point(field_add:mud.player_book.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
player_book::players() const {
  // @@protoc_insertion_point(field_list:mud.player_book.players)
  return players_;
}

// -------------------------------------------------------------------

// direction

// .mud.direction.direction_enum value = 1;
inline void direction::clear_value() {
  value_ = 0;
}
inline ::mud::direction_direction_enum direction::_internal_value() const {
  return static_cast< ::mud::direction_direction_enum >(value_);
}
inline ::mud::direction_direction_enum direction::value() const {
  // @@protoc_insertion_point(field_get:mud.direction.value)
  return _internal_value();
}
inline void direction::_internal_set_value(::mud::direction_direction_enum value) {
  
  value_ = value;
}
inline void direction::set_value(::mud::direction_direction_enum value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.direction.value)
}

// -------------------------------------------------------------------

// attribute

// .mud.attribute.attribute_name name = 1;
inline void attribute::clear_name() {
  name_ = 0;
}
inline ::mud::attribute_attribute_name attribute::_internal_name() const {
  return static_cast< ::mud::attribute_attribute_name >(name_);
}
inline ::mud::attribute_attribute_name attribute::name() const {
  // @@protoc_insertion_point(field_get:mud.attribute.name)
  return _internal_name();
}
inline void attribute::_internal_set_name(::mud::attribute_attribute_name value) {
  
  name_ = value;
}
inline void attribute::set_name(::mud::attribute_attribute_name value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.attribute.name)
}

// int64 value = 2;
inline void attribute::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 attribute::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 attribute::value() const {
  // @@protoc_insertion_point(field_get:mud.attribute.value)
  return _internal_value();
}
inline void attribute::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void attribute::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.attribute.value)
}

// int64 regen = 3;
inline void attribute::clear_regen() {
  regen_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 attribute::_internal_regen() const {
  return regen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 attribute::regen() const {
  // @@protoc_insertion_point(field_get:mud.attribute.regen)
  return _internal_regen();
}
inline void attribute::_internal_set_regen(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  regen_ = value;
}
inline void attribute::set_regen(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_regen(value);
  // @@protoc_insertion_point(field_set:mud.attribute.regen)
}

// -------------------------------------------------------------------

// character_state

// .mud.character_state.character_state_enum value = 1;
inline void character_state::clear_value() {
  value_ = 0;
}
inline ::mud::character_state_character_state_enum character_state::_internal_value() const {
  return static_cast< ::mud::character_state_character_state_enum >(value_);
}
inline ::mud::character_state_character_state_enum character_state::value() const {
  // @@protoc_insertion_point(field_get:mud.character_state.value)
  return _internal_value();
}
inline void character_state::_internal_set_value(::mud::character_state_character_state_enum value) {
  
  value_ = value;
}
inline void character_state::set_value(::mud::character_state_character_state_enum value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.character_state.value)
}

// -------------------------------------------------------------------

// character

// string name = 1;
inline void character::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& character::name() const {
  // @@protoc_insertion_point(field_get:mud.character.name)
  return _internal_name();
}
inline void character::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.character.name)
}
inline std::string* character::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.character.name)
  return _internal_mutable_name();
}
inline const std::string& character::_internal_name() const {
  return name_.GetNoArena();
}
inline void character::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void character::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.character.name)
}
inline void character::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.character.name)
}
inline void character::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.character.name)
}
inline std::string* character::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* character::release_name() {
  // @@protoc_insertion_point(field_release:mud.character.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.character.name)
}

// int64 id = 2;
inline void character::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::id() const {
  // @@protoc_insertion_point(field_get:mud.character.id)
  return _internal_id();
}
inline void character::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void character::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.character.id)
}

// int64 tile_id = 3;
inline void character::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.character.tile_id)
  return _internal_tile_id();
}
inline void character::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void character::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.character.tile_id)
}

// .mud.direction facing = 4;
inline bool character::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool character::has_facing() const {
  return _internal_has_facing();
}
inline void character::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::direction& character::_internal_facing() const {
  const ::mud::direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& character::facing() const {
  // @@protoc_insertion_point(field_get:mud.character.facing)
  return _internal_facing();
}
inline ::mud::direction* character::release_facing() {
  // @@protoc_insertion_point(field_release:mud.character.facing)
  
  ::mud::direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::direction* character::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::direction* character::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.character.facing)
  return _internal_mutable_facing();
}
inline void character::set_allocated_facing(::mud::direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.character.facing)
}

// repeated .mud.attribute attributes = 5;
inline int character::_internal_attributes_size() const {
  return attributes_.size();
}
inline int character::attributes_size() const {
  return _internal_attributes_size();
}
inline void character::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::attribute* character::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
character::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.character.attributes)
  return &attributes_;
}
inline const ::mud::attribute& character::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::attribute& character::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.character.attributes)
  return _internal_attributes(index);
}
inline ::mud::attribute* character::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::attribute* character::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.character.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
character::attributes() const {
  // @@protoc_insertion_point(field_list:mud.character.attributes)
  return attributes_;
}

// .mud.character_state state = 6;
inline bool character::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool character::has_state() const {
  return _internal_has_state();
}
inline void character::clear_state() {
  if (GetArenaNoVirtual() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::mud::character_state& character::_internal_state() const {
  const ::mud::character_state* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::character_state*>(
      &::mud::_character_state_default_instance_);
}
inline const ::mud::character_state& character::state() const {
  // @@protoc_insertion_point(field_get:mud.character.state)
  return _internal_state();
}
inline ::mud::character_state* character::release_state() {
  // @@protoc_insertion_point(field_release:mud.character.state)
  
  ::mud::character_state* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::mud::character_state* character::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::character_state>(GetArenaNoVirtual());
    state_ = p;
  }
  return state_;
}
inline ::mud::character_state* character::mutable_state() {
  // @@protoc_insertion_point(field_mutable:mud.character.state)
  return _internal_mutable_state();
}
inline void character::set_allocated_state(::mud::character_state* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:mud.character.state)
}

// -------------------------------------------------------------------

// enemy

// string name = 1;
inline void enemy::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& enemy::name() const {
  // @@protoc_insertion_point(field_get:mud.enemy.name)
  return _internal_name();
}
inline void enemy::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.enemy.name)
}
inline std::string* enemy::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.name)
  return _internal_mutable_name();
}
inline const std::string& enemy::_internal_name() const {
  return name_.GetNoArena();
}
inline void enemy::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void enemy::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.enemy.name)
}
inline void enemy::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.enemy.name)
}
inline void enemy::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.enemy.name)
}
inline std::string* enemy::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* enemy::release_name() {
  // @@protoc_insertion_point(field_release:mud.enemy.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void enemy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.name)
}

// int64 id = 2;
inline void enemy::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.id)
  return _internal_id();
}
inline void enemy::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void enemy::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.id)
}

// int64 tile_id = 3;
inline void enemy::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.tile_id)
  return _internal_tile_id();
}
inline void enemy::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void enemy::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.tile_id)
}

// .mud.direction facing = 4;
inline bool enemy::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool enemy::has_facing() const {
  return _internal_has_facing();
}
inline void enemy::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::direction& enemy::_internal_facing() const {
  const ::mud::direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& enemy::facing() const {
  // @@protoc_insertion_point(field_get:mud.enemy.facing)
  return _internal_facing();
}
inline ::mud::direction* enemy::release_facing() {
  // @@protoc_insertion_point(field_release:mud.enemy.facing)
  
  ::mud::direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::direction* enemy::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::direction* enemy::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.facing)
  return _internal_mutable_facing();
}
inline void enemy::set_allocated_facing(::mud::direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.facing)
}

// repeated .mud.attribute attributes = 5;
inline int enemy::_internal_attributes_size() const {
  return attributes_.size();
}
inline int enemy::attributes_size() const {
  return _internal_attributes_size();
}
inline void enemy::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::attribute* enemy::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
enemy::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy.attributes)
  return &attributes_;
}
inline const ::mud::attribute& enemy::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::attribute& enemy::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy.attributes)
  return _internal_attributes(index);
}
inline ::mud::attribute* enemy::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::attribute* enemy::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.enemy.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
enemy::attributes() const {
  // @@protoc_insertion_point(field_list:mud.enemy.attributes)
  return attributes_;
}

// .mud.character_state state = 6;
inline bool enemy::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool enemy::has_state() const {
  return _internal_has_state();
}
inline void enemy::clear_state() {
  if (GetArenaNoVirtual() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::mud::character_state& enemy::_internal_state() const {
  const ::mud::character_state* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::character_state*>(
      &::mud::_character_state_default_instance_);
}
inline const ::mud::character_state& enemy::state() const {
  // @@protoc_insertion_point(field_get:mud.enemy.state)
  return _internal_state();
}
inline ::mud::character_state* enemy::release_state() {
  // @@protoc_insertion_point(field_release:mud.enemy.state)
  
  ::mud::character_state* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::mud::character_state* enemy::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::character_state>(GetArenaNoVirtual());
    state_ = p;
  }
  return state_;
}
inline ::mud::character_state* enemy::mutable_state() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.state)
  return _internal_mutable_state();
}
inline void enemy::set_allocated_state(::mud::character_state* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.state)
}

// -------------------------------------------------------------------

// character_book

// repeated .mud.character characters = 1;
inline int character_book::_internal_characters_size() const {
  return characters_.size();
}
inline int character_book::characters_size() const {
  return _internal_characters_size();
}
inline void character_book::clear_characters() {
  characters_.Clear();
}
inline ::mud::character* character_book::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character_book.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
character_book::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.character_book.characters)
  return &characters_;
}
inline const ::mud::character& character_book::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& character_book::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.character_book.characters)
  return _internal_characters(index);
}
inline ::mud::character* character_book::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* character_book::add_characters() {
  // @@protoc_insertion_point(field_add:mud.character_book.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
character_book::characters() const {
  // @@protoc_insertion_point(field_list:mud.character_book.characters)
  return characters_;
}

// -------------------------------------------------------------------

// enemy_book

// repeated .mud.enemy enemies = 1;
inline int enemy_book::_internal_enemies_size() const {
  return enemies_.size();
}
inline int enemy_book::enemies_size() const {
  return _internal_enemies_size();
}
inline void enemy_book::clear_enemies() {
  enemies_.Clear();
}
inline ::mud::enemy* enemy_book::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy_book.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
enemy_book::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy_book.enemies)
  return &enemies_;
}
inline const ::mud::enemy& enemy_book::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::mud::enemy& enemy_book::enemies(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy_book.enemies)
  return _internal_enemies(index);
}
inline ::mud::enemy* enemy_book::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::mud::enemy* enemy_book::add_enemies() {
  // @@protoc_insertion_point(field_add:mud.enemy_book.enemies)
  return _internal_add_enemies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
enemy_book::enemies() const {
  // @@protoc_insertion_point(field_list:mud.enemy_book.enemies)
  return enemies_;
}

// -------------------------------------------------------------------

// neighbour

// .mud.direction neighbour_direction = 1;
inline bool neighbour::_internal_has_neighbour_direction() const {
  return this != internal_default_instance() && neighbour_direction_ != nullptr;
}
inline bool neighbour::has_neighbour_direction() const {
  return _internal_has_neighbour_direction();
}
inline void neighbour::clear_neighbour_direction() {
  if (GetArenaNoVirtual() == nullptr && neighbour_direction_ != nullptr) {
    delete neighbour_direction_;
  }
  neighbour_direction_ = nullptr;
}
inline const ::mud::direction& neighbour::_internal_neighbour_direction() const {
  const ::mud::direction* p = neighbour_direction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& neighbour::neighbour_direction() const {
  // @@protoc_insertion_point(field_get:mud.neighbour.neighbour_direction)
  return _internal_neighbour_direction();
}
inline ::mud::direction* neighbour::release_neighbour_direction() {
  // @@protoc_insertion_point(field_release:mud.neighbour.neighbour_direction)
  
  ::mud::direction* temp = neighbour_direction_;
  neighbour_direction_ = nullptr;
  return temp;
}
inline ::mud::direction* neighbour::_internal_mutable_neighbour_direction() {
  
  if (neighbour_direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    neighbour_direction_ = p;
  }
  return neighbour_direction_;
}
inline ::mud::direction* neighbour::mutable_neighbour_direction() {
  // @@protoc_insertion_point(field_mutable:mud.neighbour.neighbour_direction)
  return _internal_mutable_neighbour_direction();
}
inline void neighbour::set_allocated_neighbour_direction(::mud::direction* neighbour_direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete neighbour_direction_;
  }
  if (neighbour_direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      neighbour_direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neighbour_direction, submessage_arena);
    }
    
  } else {
    
  }
  neighbour_direction_ = neighbour_direction;
  // @@protoc_insertion_point(field_set_allocated:mud.neighbour.neighbour_direction)
}

// int64 neighbour_tile_id = 2;
inline void neighbour::clear_neighbour_tile_id() {
  neighbour_tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 neighbour::_internal_neighbour_tile_id() const {
  return neighbour_tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 neighbour::neighbour_tile_id() const {
  // @@protoc_insertion_point(field_get:mud.neighbour.neighbour_tile_id)
  return _internal_neighbour_tile_id();
}
inline void neighbour::_internal_set_neighbour_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  neighbour_tile_id_ = value;
}
inline void neighbour::set_neighbour_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_neighbour_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.neighbour.neighbour_tile_id)
}

// -------------------------------------------------------------------

// tile

// int64 id = 1;
inline void tile::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::id() const {
  // @@protoc_insertion_point(field_get:mud.tile.id)
  return _internal_id();
}
inline void tile::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void tile::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.id)
}

// .mud.tile.tile_type type = 2;
inline void tile::clear_type() {
  type_ = 0;
}
inline ::mud::tile_tile_type tile::_internal_type() const {
  return static_cast< ::mud::tile_tile_type >(type_);
}
inline ::mud::tile_tile_type tile::type() const {
  // @@protoc_insertion_point(field_get:mud.tile.type)
  return _internal_type();
}
inline void tile::_internal_set_type(::mud::tile_tile_type value) {
  
  type_ = value;
}
inline void tile::set_type(::mud::tile_tile_type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.type)
}

// repeated .mud.neighbour neighbours = 3;
inline int tile::_internal_neighbours_size() const {
  return neighbours_.size();
}
inline int tile::neighbours_size() const {
  return _internal_neighbours_size();
}
inline void tile::clear_neighbours() {
  neighbours_.Clear();
}
inline ::mud::neighbour* tile::mutable_neighbours(int index) {
  // @@protoc_insertion_point(field_mutable:mud.tile.neighbours)
  return neighbours_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::neighbour >*
tile::mutable_neighbours() {
  // @@protoc_insertion_point(field_mutable_list:mud.tile.neighbours)
  return &neighbours_;
}
inline const ::mud::neighbour& tile::_internal_neighbours(int index) const {
  return neighbours_.Get(index);
}
inline const ::mud::neighbour& tile::neighbours(int index) const {
  // @@protoc_insertion_point(field_get:mud.tile.neighbours)
  return _internal_neighbours(index);
}
inline ::mud::neighbour* tile::_internal_add_neighbours() {
  return neighbours_.Add();
}
inline ::mud::neighbour* tile::add_neighbours() {
  // @@protoc_insertion_point(field_add:mud.tile.neighbours)
  return _internal_add_neighbours();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::neighbour >&
tile::neighbours() const {
  // @@protoc_insertion_point(field_list:mud.tile.neighbours)
  return neighbours_;
}

// .mud.tile.resident_type occupant_type = 4;
inline void tile::clear_occupant_type() {
  occupant_type_ = 0;
}
inline ::mud::tile_resident_type tile::_internal_occupant_type() const {
  return static_cast< ::mud::tile_resident_type >(occupant_type_);
}
inline ::mud::tile_resident_type tile::occupant_type() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_type)
  return _internal_occupant_type();
}
inline void tile::_internal_set_occupant_type(::mud::tile_resident_type value) {
  
  occupant_type_ = value;
}
inline void tile::set_occupant_type(::mud::tile_resident_type value) {
  _internal_set_occupant_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_type)
}

// int64 occupant_id = 5;
inline void tile::clear_occupant_id() {
  occupant_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_occupant_id() const {
  return occupant_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::occupant_id() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_id)
  return _internal_occupant_id();
}
inline void tile::_internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  occupant_id_ = value;
}
inline void tile::set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_occupant_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_id)
}

// string mood = 6;
inline void tile::clear_mood() {
  mood_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& tile::mood() const {
  // @@protoc_insertion_point(field_get:mud.tile.mood)
  return _internal_mood();
}
inline void tile::set_mood(const std::string& value) {
  _internal_set_mood(value);
  // @@protoc_insertion_point(field_set:mud.tile.mood)
}
inline std::string* tile::mutable_mood() {
  // @@protoc_insertion_point(field_mutable:mud.tile.mood)
  return _internal_mutable_mood();
}
inline const std::string& tile::_internal_mood() const {
  return mood_.GetNoArena();
}
inline void tile::_internal_set_mood(const std::string& value) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tile::set_mood(std::string&& value) {
  
  mood_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.tile.mood)
}
inline void tile::set_mood(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.tile.mood)
}
inline void tile::set_mood(const char* value, size_t size) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.tile.mood)
}
inline std::string* tile::_internal_mutable_mood() {
  
  return mood_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tile::release_mood() {
  // @@protoc_insertion_point(field_release:mud.tile.mood)
  
  return mood_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tile::set_allocated_mood(std::string* mood) {
  if (mood != nullptr) {
    
  } else {
    
  }
  mood_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mood);
  // @@protoc_insertion_point(field_set_allocated:mud.tile.mood)
}

// -------------------------------------------------------------------

// tile_book

// repeated .mud.tile tiles = 1;
inline int tile_book::_internal_tiles_size() const {
  return tiles_.size();
}
inline int tile_book::tiles_size() const {
  return _internal_tiles_size();
}
inline void tile_book::clear_tiles() {
  tiles_.Clear();
}
inline ::mud::tile* tile_book::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:mud.tile_book.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
tile_book::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:mud.tile_book.tiles)
  return &tiles_;
}
inline const ::mud::tile& tile_book::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::mud::tile& tile_book::tiles(int index) const {
  // @@protoc_insertion_point(field_get:mud.tile_book.tiles)
  return _internal_tiles(index);
}
inline ::mud::tile* tile_book::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::mud::tile* tile_book::add_tiles() {
  // @@protoc_insertion_point(field_add:mud.tile_book.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
tile_book::tiles() const {
  // @@protoc_insertion_point(field_list:mud.tile_book.tiles)
  return tiles_;
}

// -------------------------------------------------------------------

// token_in

// -------------------------------------------------------------------

// token_out

// int64 token = 1;
inline void token_out::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 token_out::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 token_out::token() const {
  // @@protoc_insertion_point(field_get:mud.token_out.token)
  return _internal_token();
}
inline void token_out::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  token_ = value;
}
inline void token_out::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mud.token_out.token)
}

// -------------------------------------------------------------------

// login_in

// string name = 1;
inline void login_in::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& login_in::name() const {
  // @@protoc_insertion_point(field_get:mud.login_in.name)
  return _internal_name();
}
inline void login_in::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.login_in.name)
}
inline std::string* login_in::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.login_in.name)
  return _internal_mutable_name();
}
inline const std::string& login_in::_internal_name() const {
  return name_.GetNoArena();
}
inline void login_in::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void login_in::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.login_in.name)
}
inline void login_in::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.login_in.name)
}
inline void login_in::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.login_in.name)
}
inline std::string* login_in::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* login_in::release_name() {
  // @@protoc_insertion_point(field_release:mud.login_in.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void login_in::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.login_in.name)
}

// string hash = 2;
inline void login_in::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& login_in::hash() const {
  // @@protoc_insertion_point(field_get:mud.login_in.hash)
  return _internal_hash();
}
inline void login_in::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:mud.login_in.hash)
}
inline std::string* login_in::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:mud.login_in.hash)
  return _internal_mutable_hash();
}
inline const std::string& login_in::_internal_hash() const {
  return hash_.GetNoArena();
}
inline void login_in::_internal_set_hash(const std::string& value) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void login_in::set_hash(std::string&& value) {
  
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.login_in.hash)
}
inline void login_in::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.login_in.hash)
}
inline void login_in::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.login_in.hash)
}
inline std::string* login_in::_internal_mutable_hash() {
  
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* login_in::release_hash() {
  // @@protoc_insertion_point(field_release:mud.login_in.hash)
  
  return hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void login_in::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:mud.login_in.hash)
}

// int64 token = 3;
inline void login_in::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_in::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_in::token() const {
  // @@protoc_insertion_point(field_get:mud.login_in.token)
  return _internal_token();
}
inline void login_in::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  token_ = value;
}
inline void login_in::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mud.login_in.token)
}

// -------------------------------------------------------------------

// login_out

// repeated .mud.character characters = 1;
inline int login_out::_internal_characters_size() const {
  return characters_.size();
}
inline int login_out::characters_size() const {
  return _internal_characters_size();
}
inline void login_out::clear_characters() {
  characters_.Clear();
}
inline ::mud::character* login_out::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.login_out.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
login_out::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.login_out.characters)
  return &characters_;
}
inline const ::mud::character& login_out::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& login_out::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.login_out.characters)
  return _internal_characters(index);
}
inline ::mud::character* login_out::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* login_out::add_characters() {
  // @@protoc_insertion_point(field_add:mud.login_out.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
login_out::characters() const {
  // @@protoc_insertion_point(field_list:mud.login_out.characters)
  return characters_;
}

// .mud.login_out.login_state_enum login_state = 2;
inline void login_out::clear_login_state() {
  login_state_ = 0;
}
inline ::mud::login_out_login_state_enum login_out::_internal_login_state() const {
  return static_cast< ::mud::login_out_login_state_enum >(login_state_);
}
inline ::mud::login_out_login_state_enum login_out::login_state() const {
  // @@protoc_insertion_point(field_get:mud.login_out.login_state)
  return _internal_login_state();
}
inline void login_out::_internal_set_login_state(::mud::login_out_login_state_enum value) {
  
  login_state_ = value;
}
inline void login_out::set_login_state(::mud::login_out_login_state_enum value) {
  _internal_set_login_state(value);
  // @@protoc_insertion_point(field_set:mud.login_out.login_state)
}

// -------------------------------------------------------------------

// select_character_in

// string name = 1;
inline void select_character_in::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& select_character_in::name() const {
  // @@protoc_insertion_point(field_get:mud.select_character_in.name)
  return _internal_name();
}
inline void select_character_in::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.select_character_in.name)
}
inline std::string* select_character_in::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.select_character_in.name)
  return _internal_mutable_name();
}
inline const std::string& select_character_in::_internal_name() const {
  return name_.GetNoArena();
}
inline void select_character_in::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void select_character_in::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.select_character_in.name)
}
inline void select_character_in::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.select_character_in.name)
}
inline void select_character_in::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.select_character_in.name)
}
inline std::string* select_character_in::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* select_character_in::release_name() {
  // @@protoc_insertion_point(field_release:mud.select_character_in.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void select_character_in::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.select_character_in.name)
}

// int64 token = 2;
inline void select_character_in::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::token() const {
  // @@protoc_insertion_point(field_get:mud.select_character_in.token)
  return _internal_token();
}
inline void select_character_in::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  token_ = value;
}
inline void select_character_in::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mud.select_character_in.token)
}

// .mud.select_character_in.action_type action = 3;
inline void select_character_in::clear_action() {
  action_ = 0;
}
inline ::mud::select_character_in_action_type select_character_in::_internal_action() const {
  return static_cast< ::mud::select_character_in_action_type >(action_);
}
inline ::mud::select_character_in_action_type select_character_in::action() const {
  // @@protoc_insertion_point(field_get:mud.select_character_in.action)
  return _internal_action();
}
inline void select_character_in::_internal_set_action(::mud::select_character_in_action_type value) {
  
  action_ = value;
}
inline void select_character_in::set_action(::mud::select_character_in_action_type value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:mud.select_character_in.action)
}

// -------------------------------------------------------------------

// select_character_out

// .mud.character selected_character = 1;
inline bool select_character_out::_internal_has_selected_character() const {
  return this != internal_default_instance() && selected_character_ != nullptr;
}
inline bool select_character_out::has_selected_character() const {
  return _internal_has_selected_character();
}
inline void select_character_out::clear_selected_character() {
  if (GetArenaNoVirtual() == nullptr && selected_character_ != nullptr) {
    delete selected_character_;
  }
  selected_character_ = nullptr;
}
inline const ::mud::character& select_character_out::_internal_selected_character() const {
  const ::mud::character* p = selected_character_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::character*>(
      &::mud::_character_default_instance_);
}
inline const ::mud::character& select_character_out::selected_character() const {
  // @@protoc_insertion_point(field_get:mud.select_character_out.selected_character)
  return _internal_selected_character();
}
inline ::mud::character* select_character_out::release_selected_character() {
  // @@protoc_insertion_point(field_release:mud.select_character_out.selected_character)
  
  ::mud::character* temp = selected_character_;
  selected_character_ = nullptr;
  return temp;
}
inline ::mud::character* select_character_out::_internal_mutable_selected_character() {
  
  if (selected_character_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::character>(GetArenaNoVirtual());
    selected_character_ = p;
  }
  return selected_character_;
}
inline ::mud::character* select_character_out::mutable_selected_character() {
  // @@protoc_insertion_point(field_mutable:mud.select_character_out.selected_character)
  return _internal_mutable_selected_character();
}
inline void select_character_out::set_allocated_selected_character(::mud::character* selected_character) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete selected_character_;
  }
  if (selected_character) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      selected_character = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected_character, submessage_arena);
    }
    
  } else {
    
  }
  selected_character_ = selected_character;
  // @@protoc_insertion_point(field_set_allocated:mud.select_character_out.selected_character)
}

// .mud.select_character_out.result_enum result = 2;
inline void select_character_out::clear_result() {
  result_ = 0;
}
inline ::mud::select_character_out_result_enum select_character_out::_internal_result() const {
  return static_cast< ::mud::select_character_out_result_enum >(result_);
}
inline ::mud::select_character_out_result_enum select_character_out::result() const {
  // @@protoc_insertion_point(field_get:mud.select_character_out.result)
  return _internal_result();
}
inline void select_character_out::_internal_set_result(::mud::select_character_out_result_enum value) {
  
  result_ = value;
}
inline void select_character_out::set_result(::mud::select_character_out_result_enum value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:mud.select_character_out.result)
}

// -------------------------------------------------------------------

// play_in

// int64 token = 1;
inline void play_in::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::token() const {
  // @@protoc_insertion_point(field_get:mud.play_in.token)
  return _internal_token();
}
inline void play_in::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  token_ = value;
}
inline void play_in::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mud.play_in.token)
}

// int64 player_id = 2;
inline void play_in::clear_player_id() {
  player_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::player_id() const {
  // @@protoc_insertion_point(field_get:mud.play_in.player_id)
  return _internal_player_id();
}
inline void play_in::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  player_id_ = value;
}
inline void play_in::set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:mud.play_in.player_id)
}

// int64 character_id = 3;
inline void play_in::clear_character_id() {
  character_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_character_id() const {
  return character_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::character_id() const {
  // @@protoc_insertion_point(field_get:mud.play_in.character_id)
  return _internal_character_id();
}
inline void play_in::_internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  character_id_ = value;
}
inline void play_in::set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_character_id(value);
  // @@protoc_insertion_point(field_set:mud.play_in.character_id)
}

// .mud.play_in.input_enum command = 4;
inline void play_in::clear_command() {
  command_ = 0;
}
inline ::mud::play_in_input_enum play_in::_internal_command() const {
  return static_cast< ::mud::play_in_input_enum >(command_);
}
inline ::mud::play_in_input_enum play_in::command() const {
  // @@protoc_insertion_point(field_get:mud.play_in.command)
  return _internal_command();
}
inline void play_in::_internal_set_command(::mud::play_in_input_enum value) {
  
  command_ = value;
}
inline void play_in::set_command(::mud::play_in_input_enum value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:mud.play_in.command)
}

// -------------------------------------------------------------------

// play_out

// int64 character_id = 1;
inline void play_out::clear_character_id() {
  character_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_out::_internal_character_id() const {
  return character_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_out::character_id() const {
  // @@protoc_insertion_point(field_get:mud.play_out.character_id)
  return _internal_character_id();
}
inline void play_out::_internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  character_id_ = value;
}
inline void play_out::set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_character_id(value);
  // @@protoc_insertion_point(field_set:mud.play_out.character_id)
}

// .mud.play_out.status_enum status = 2;
inline void play_out::clear_status() {
  status_ = 0;
}
inline ::mud::play_out_status_enum play_out::_internal_status() const {
  return static_cast< ::mud::play_out_status_enum >(status_);
}
inline ::mud::play_out_status_enum play_out::status() const {
  // @@protoc_insertion_point(field_get:mud.play_out.status)
  return _internal_status();
}
inline void play_out::_internal_set_status(::mud::play_out_status_enum value) {
  
  status_ = value;
}
inline void play_out::set_status(::mud::play_out_status_enum value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mud.play_out.status)
}

// repeated .mud.tile tiles = 3;
inline int play_out::_internal_tiles_size() const {
  return tiles_.size();
}
inline int play_out::tiles_size() const {
  return _internal_tiles_size();
}
inline void play_out::clear_tiles() {
  tiles_.Clear();
}
inline ::mud::tile* play_out::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
play_out::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.tiles)
  return &tiles_;
}
inline const ::mud::tile& play_out::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::mud::tile& play_out::tiles(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.tiles)
  return _internal_tiles(index);
}
inline ::mud::tile* play_out::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::mud::tile* play_out::add_tiles() {
  // @@protoc_insertion_point(field_add:mud.play_out.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
play_out::tiles() const {
  // @@protoc_insertion_point(field_list:mud.play_out.tiles)
  return tiles_;
}

// repeated .mud.character characters = 4;
inline int play_out::_internal_characters_size() const {
  return characters_.size();
}
inline int play_out::characters_size() const {
  return _internal_characters_size();
}
inline void play_out::clear_characters() {
  characters_.Clear();
}
inline ::mud::character* play_out::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
play_out::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.characters)
  return &characters_;
}
inline const ::mud::character& play_out::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& play_out::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.characters)
  return _internal_characters(index);
}
inline ::mud::character* play_out::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* play_out::add_characters() {
  // @@protoc_insertion_point(field_add:mud.play_out.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
play_out::characters() const {
  // @@protoc_insertion_point(field_list:mud.play_out.characters)
  return characters_;
}

// repeated .mud.enemy enemies = 5;
inline int play_out::_internal_enemies_size() const {
  return enemies_.size();
}
inline int play_out::enemies_size() const {
  return _internal_enemies_size();
}
inline void play_out::clear_enemies() {
  enemies_.Clear();
}
inline ::mud::enemy* play_out::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
play_out::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.enemies)
  return &enemies_;
}
inline const ::mud::enemy& play_out::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::mud::enemy& play_out::enemies(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.enemies)
  return _internal_enemies(index);
}
inline ::mud::enemy* play_out::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::mud::enemy* play_out::add_enemies() {
  // @@protoc_insertion_point(field_add:mud.play_out.enemies)
  return _internal_add_enemies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
play_out::enemies() const {
  // @@protoc_insertion_point(field_list:mud.play_out.enemies)
  return enemies_;
}

// -------------------------------------------------------------------

// logout_in

// int64 token = 1;
inline void logout_in::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::token() const {
  // @@protoc_insertion_point(field_get:mud.logout_in.token)
  return _internal_token();
}
inline void logout_in::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  token_ = value;
}
inline void logout_in::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:mud.logout_in.token)
}

// int64 player_id = 2;
inline void logout_in::clear_player_id() {
  player_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::player_id() const {
  // @@protoc_insertion_point(field_get:mud.logout_in.player_id)
  return _internal_player_id();
}
inline void logout_in::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  player_id_ = value;
}
inline void logout_in::set_player_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:mud.logout_in.player_id)
}

// int64 character_id = 3;
inline void logout_in::clear_character_id() {
  character_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::_internal_character_id() const {
  return character_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 logout_in::character_id() const {
  // @@protoc_insertion_point(field_get:mud.logout_in.character_id)
  return _internal_character_id();
}
inline void logout_in::_internal_set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  character_id_ = value;
}
inline void logout_in::set_character_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_character_id(value);
  // @@protoc_insertion_point(field_set:mud.logout_in.character_id)
}

// -------------------------------------------------------------------

// logout_out

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mud

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mud::direction_direction_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::direction_direction_enum>() {
  return ::mud::direction_direction_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::attribute_attribute_name> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::attribute_attribute_name>() {
  return ::mud::attribute_attribute_name_descriptor();
}
template <> struct is_proto_enum< ::mud::character_state_character_state_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::character_state_character_state_enum>() {
  return ::mud::character_state_character_state_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::tile_tile_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::tile_tile_type>() {
  return ::mud::tile_tile_type_descriptor();
}
template <> struct is_proto_enum< ::mud::tile_resident_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::tile_resident_type>() {
  return ::mud::tile_resident_type_descriptor();
}
template <> struct is_proto_enum< ::mud::login_out_login_state_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::login_out_login_state_enum>() {
  return ::mud::login_out_login_state_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::select_character_in_action_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::select_character_in_action_type>() {
  return ::mud::select_character_in_action_type_descriptor();
}
template <> struct is_proto_enum< ::mud::select_character_out_result_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::select_character_out_result_enum>() {
  return ::mud::select_character_out_result_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::play_in_input_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::play_in_input_enum>() {
  return ::mud::play_in_input_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::play_out_status_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::play_out_status_enum>() {
  return ::mud::play_out_status_enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
